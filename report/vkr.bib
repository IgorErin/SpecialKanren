% !TeX spellcheck = ru_RU

@article{unapp,
author = {Byrd, William E. and Ballantyne, Michael and Rosenblatt, Gregory and Might, Matthew},
title = {A Unified Approach to Solving Seven Programming Problems (Functional Pearl)},
year = {2017},
issue_date = {September 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {1},
number = {ICFP},
url = {https://doi.org/10.1145/3110252},
doi = {10.1145/3110252},
abstract = {We present seven programming challenges in Racket, and an elegant, unified approach to solving them using constraint logic programming in miniKanren.},
journal = {Proc. ACM Program. Lang.},
month = {aug},
articleno = {8},
numpages = {26},
keywords = {miniKanren, relational programming, Scheme, program synthesis, Racket}
}

@InProceedings{JGS,
author="Lozov, Peter
and Kosarev, Dmitry
and Ivanov, Dmitry
and Boulytchev, Dmitry",
editor="Gl{\"u}ck, Robert
and Kafle, Bishoksan",
title="Relational Solver for Java Generics Type System",
booktitle="Logic-Based Program Synthesis and Transformation",
year="2023",
publisher="Springer Nature Switzerland",
address="Cham",
pages="118--128",
abstract="We present a solver for Java generics type system implemented using relational verifier-to-solver approach. The solver finds solutions for a system of subtyping inequations with free variables and thus can be used to determine a concrete type satisfying a set of constraints. The context of this work is symbolic execution for testing and verification of Java programs.",
isbn="978-3-031-45784-5"
}

@book{pargen,
author = {Jones, Neil and Gomard, Carsten and Sestoft, Peter},
year = {1993},
month = {01},
pages = {},
title = {Partial Evaluation and Automatic Program Generation},
isbn = {0-13-020249-5}
}

@article{supercompiler,
author = {Turchin, Valentin F.},
title = {The Concept of a Supercompiler},
year = {1986},
issue_date = {July 1986},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {3},
issn = {0164-0925},
url = {https://doi.org/10.1145/5956.5957},
doi = {10.1145/5956.5957},
abstract = {A supercompiler is a program transformer of a certain type. It traces the possible generalized histories of computation by the original program, and compiles an equivalent program, reducing in the process the redundancy that could be present in the original program. The nature of the redundancy that can be eliminated by supercompilation may be various, e.g., some variables might have predefined values (as in partial evaluation), or the structure of control transfer could be made more efficient (as in lazy evaluation), or it could simply be the fact that the same variable is used more than once. The general principles of supercompilation are described and compared with the usual approach to program transformation as a stepwise application of a number of equivalence rules. It is argued that the language Refal serves the needs of supercompilation best. Refal is formally defined and compared with Prolog and other languages. Examples are given of the operation of a Refal supercompiler implemented at CCNY on an IBM/370.},
journal = {ACM Trans. Program. Lang. Syst.},
month = {jun},
pages = {292–325},
numpages = {34}
}

@article{miniDeduction,
   title={An Empirical Study of Partial Deduction for miniKanren},
   volume={341},
   ISSN={2075-2180},
   url={http://dx.doi.org/10.4204/EPTCS.341.5},
   DOI={10.4204/eptcs.341.5},
   journal={Electronic Proceedings in Theoretical Computer Science},
   publisher={Open Publishing Association},
   author={Verbitskaia, Ekaterina and Berezun, Daniil and Boulytchev, Dmitry},
   year={2021},
   month=sep, pages={73–94} }

@inproceedings{relinter,
author = {Byrd, William E. and Holk, Eric and Friedman, Daniel P.},
title = {MiniKanren, Live and Untagged: Quine Generation via Relational Interpreters (Programming Pearl)},
year = {2012},
isbn = {9781450318952},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2661103.2661105},
doi = {10.1145/2661103.2661105},
abstract = {We present relational interpreters for several subsets of Scheme, written in the pure logic programming language miniKanren. We demonstrate these interpreters running "backwards"---that is, generating programs that evaluate to a specified value---and show how the interpreters can trivially generate quines (programs that evaluate to themselves). We demonstrate how to transform environment-passing interpreters written in Scheme into relational interpreters written in miniKanren. We show how constraint extensions to core miniKanren can be used to allow shadowing of the interpreter's primitive forms (using the absent° tree constraint), and to avoid having to tag expressions in the languages being interpreted (using disequality constraints and symbol/number type-constraints), simplifying the interpreters and eliminating the need for parsers/unparsers.We provide four appendices to make the code in the paper completely self-contained. Three of these appendices contain new code: the complete implementation of core miniKanren extended with the new constraints; an extended relational interpreter capable of running factorial and doing list processing; and a simple pattern matcher that uses Dijkstra guards. The other appendix presents our preferred version of code that has been presented elsewhere: the miniKanren relational arithmetic system used in the extended interpreter.},
booktitle = {Proceedings of the 2012 Annual Workshop on Scheme and Functional Programming},
pages = {8–29},
numpages = {22},
keywords = {scheme, tagging, interpreters, logic programming, miniKanren, quines, relational programming},
location = {Copenhagen, Denmark},
series = {Scheme '12}
}

@article{miniKanren,
author = {Byrd, William},
year = {2009},
month = {09},
pages = {},
title = {Relational Programming in miniKanren: Techniques, Applications, and Implementations}
}

@inproceedings{distillation,
author = {Hamilton, Geoff},
year = {2007},
month = {01},
pages = {61-70},
title = {Distillation: Extracting the essence of programs},
journal = {Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation},
doi = {10.1145/1244381.1244391}
}

@article{parded,
title = {Partial evaluation in logic programming},
journal = {The Journal of Logic Programming},
volume = {11},
number = {3},
pages = {217-242},
year = {1991},
issn = {0743-1066},
doi = {https://doi.org/10.1016/0743-1066(91)90027-M},
url = {https://www.sciencedirect.com/science/article/pii/074310669190027M},
author = {J.W. Lloyd and J.C. Shepherdson},
abstract = {This paper gives a theoretical foundation for partial evaluation in logic programming. Let P be a normal program, G a normal goal, A a finite set of atoms, and P′ a partial evaluation of P wrt A. We study, for both the declarative and procedural semantics, conditions under which P′ is sound and complete wrt P for the goal G. We identify two relevant conditions, those of closedness and independence. For the procedural semantics, we show that, if P′ ∪ {G} is A-closed and A is independent, then P′ is sound and complete wrt P for the goal G. For the declarative semantics, we show that, if P′ ∪ {G} is A-closed, then P′ is sound wrt P for the goal G. However, we show that, unless strong conditions are imposed, we do not have completeness for the declarative semantics. A practical consequence of our results is that partial evaluators should enforce the closedness and independence conditions.}
}

@Inbook{embedding,
author="Leuschel, Michael",
editor="Mogensen, Torben {\AE}.
and Schmidt, David A.
and Sudborough, I. Hal",
title="Homeomorphic Embedding for Online Termination of Symbolic Methods",
bookTitle="The Essence of Computation: Complexity, Analysis, Transformation",
year="2002",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="379--403",
abstract="Well-quasi orders in general, and homeomorphic embedding in particular, have gained popularity to ensure the termination of techniques for program analysis, specialisation, transformation, and verification. In this paper we survey and discuss this use of homeomorphic embedding and clarify the advantages of such an approach over one using well-founded orders. We also discuss various extensions of the homeomorphic embedding relation. We conclude with a study of homeomorphic embedding in the context of metaprogramming, presenting some new (positive and negative) results and open problems.",
isbn="978-3-540-36377-4",
doi="10.1007/3-540-36377-7_17",
url="https://doi.org/10.1007/3-540-36377-7_17"
}
