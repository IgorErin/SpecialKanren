% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

В данном разделе описаны подходы к реализации.

\subsection{Исходное представление}
Так как специализируемым языком выступал OCanren, встроенный в OCaml, в качестве исходного представления программ на стадии проектирования предполагалось использовать одно из представлений, которое порождает компилятор OCaml. Таковым было выбрано типизированное дерево, ибо типы необходимы для установления
конечности домена и генерации всех возможных значений.

\subsection{Промежуточное представление}

В качестве промежуточного представления была выбрана дизъюнктивная нормальная форма (далее ДНФ). Ибо она позволяет рассматривать каждый конъюнкт независимо от других. Что в свою очередь упрощает протягивание констант и редукцию всей формулы.

\subsection{Специализация}
 Рассмотрим редукцию следующей формулы.

\begin{lstlisting}[caption=Отношение вычитания, language=OCaml, frame=single, label = sub]
 let sub x y z =
    fresh (valid)
      loe y x valid
      &&& conde
            [ valid === false &&& (z === None)
            ; fresh (z_value)
                valid === true 
                &&& (z === Some z_value) 
                &&& add y z_value x)
            ]
\end{lstlisting}

Специализация будет происходить по параметру \verb|z| и конструктору \verb|Some|. Необходимо помнить, что арность данного конструктора равна единице.

Сначала формула будет приведена в дизъюнктивную нормальную форму. Объявление свежих переменных необходимо переместить, чтобы их область видимости состояла из всего конъюнкта, при необходимости переименовав. 

\begin{lstlisting}[caption=Отношение в ДНФ, language=OCaml, frame=single, label = sub]
 let sub x y z =
    fresh (valid) (loe y x valid) (valid === false) (z === None)
    ||| fresh (valid z_value)  
          (loe y x valid)
          (valid === true) 
          (z === Some z_value) 
          (add y z_value x)
        
\end{lstlisting}

Редуцируемый параметр будет заменен на параметры конструктора, в данном случае \verb|some_arg|. Все вхождения редуцируемого параметра будут заменены на конструктор с новым параметром в качестве аргумента.

\begin{lstlisting}[caption=Отношение после подстановки конструктора, language=OCaml, frame=single, label = sub]
 let sub x y some_arg =
    fresh (valid) 
        (loe y x valid)
        (valid === false) 
        (Some some_arg === None)
    ||| fresh (valid z_value)  
          (loe y x valid)
          (valid === true) 
          (Some some_arg === Some z_value) 
          (add y z_value x)
\end{lstlisting}

Теперь необходимо протянуть константы.

\subsubsection{Протягивание констант}

Все имена, к которым применялось отношение унификации будут разбиты на классы эквивалентности. После чего  в каждом классе эквивалентности будет выбран представитель. Затем все вхождения свободных переменных этого класса будут заменены на данного представителя.

\begin{lstlisting}[caption=Отношение после протягивания констант, language=OCaml, frame=single, label = sub]
 let sub x y some_arg =
    fresh (valid) 
        (loe y x false)
        (false === false) 
        (Some some_arg === None)
    ||| fresh (valid z_value)  
          (loe y x true)
          (true === true) 
          (Some some_arg === Some z_value) 
          (add y z_value x)
\end{lstlisting}

\subsubsection{Редукция}

Во время редукции производится проверка на выполнимость. Конъюнкты содержащие заведомо невыполнимую унификацию будут удалены. Избыточные конструкторы будут сняты. 

\begin{lstlisting}[caption=Отношение после редукции, language=OCaml, frame=single, label = sub]
 let sub x y some_arg =
    fresh (valid z_value)  
          (loe y x true)
          (some_arg === z_value) 
          (add y z_value x)
\end{lstlisting}

Протягивание констант и редукцию необходимо повторять до схождения к неподвижной точке.

\newpage

\begin{lstlisting}[caption=Отношение с лишними свежими именами, language=OCaml, frame=single, label = sub]
 let sub x y some_arg =
    fresh (valid z_value)  (loe y x true) (add y some_arg x)
\end{lstlisting}

После чего необходимо в каждом конъюнкте независимо удалить неиспользуемые свежие переменные.

\begin{lstlisting}[caption=Результирующее отношение, language=OCaml, frame=single, label = sub]
 let sub x y some_arg =
    fresh ()  (loe y x true) (add y some_arg x)
\end{lstlisting}

\subsubsection{Замыкание}

В результате может получиться формула, в теле которой окажутся вызовы отношений с известными параметрами. Такие отношения так же необходимо специализировать, их специализированный вызовы подставить в текущую формулу. Осуществляется это с помощью обхода графа вызовов, начиная с исходной функции.

\begin{lstlisting}[caption=Отношение со специализированным вызовом, language=OCaml, frame=single, label = sub]
 let sub x y some_arg =
    fresh ()  (loe_true y x) (add y some_arg x)
\end{lstlisting}

\subsection{Трансляция}

По редуцированной формуле строится нетипизированное дерево. Затем средствами стандартной библиотеки компилятора оно транслируется в код языка OCaml.
